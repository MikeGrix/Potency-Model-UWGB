---
title: "Double CrossVal"
author: "Michael Grix"
date: "2024-11-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(dplyr)
library(glmnet)
library(caret)
```


```{r}
############# ASSUMPTIONS #############
#Run this markdown file after Data Modeling.Rmd
#This assumes that all of the models are loaded. 

dim(data)
n = dim(data)[1]

############# Model specifications #############
# Linear
Model1 = xgb_model$finalModel
Model2 = svr_model$finalModel

allModels = list(Model1,Model2)	

```


```{r}

###################################################################
##### Double cross-validation for modeling-process assessment #####				 
###################################################################

##### model assessment OUTER shell #####
# produce loops for 10-fold cross-validation for model ASSESSMENT
nfolds = 10
groups = rep(1:nfolds,length=n)  #produces list of group labels
set.seed(42)
cvgroups = sample(groups,n)  #orders randomly

# set up storage for predicted values from the double-cross-validation
allpredictedCV = rep(NA,n)

# set up storage to see what models are "best" on the inner loops
allbestTypes = rep(NA,nfolds)
allbestPars = vector("list",nfolds)

All_columns <- c("Family","Production.Set.Point.B","Production.Set.Point.C","Production.Set.Point.D","Growth.Time.A","Growth.Slope.A","Growth.Slope.B","Growth.Max","Growth.Slope.C","Growth.Time.B","Protein.Conc.A","Protein.C","Protein.Conc.D","Adjuvent.Conc","Protein.Conc.B_KNNimputed","Protein.Conc.C_KNNimputed", "Vacc_age")

xbgImp_columns <-c("Adjuvent.Conc","Family","Vacc_age","Growth.Max","Growth.Slope.B","Protein.Conc.D","Protein.Conc.A","Protein.C","Growth.Time.B","Production.Set.Point.B")

SVRImp_columns <-c("Family","Production.Set.Point.B","Production.Set.Point.C","Growth.Slope.A","Growth.Time.B","Protein.Conc.D","Adjuvent.Conc", "Vacc_age")

train_control <- trainControl(method = "cv", number = 10)  # cross-validation

xgb_tune = xgb_model$bestTune

# loop through outer splits
for (j in 1:nfolds)  {  #be careful not to re-use loop indices
  groupj = (cvgroups == j)
  
  traindata1 = data[!groupj, c(All_columns, "log_corrected_potency")]
  traindata2 = data[!groupj, c(SVRImp_columns, "log_corrected_potency")]
  traindata3 = data[!groupj, c(xbgImp_columns, "log_corrected_potency")]
  
  validdata = data[groupj, ]

  SVR_All = train(log_corrected_potency ~ ., data = traindata1, method = "svmRadial", trControl = train_control)
  SVR_imp = train(log_corrected_potency ~ ., data = traindata2, method = "svmRadial", trControl = train_control)
  
  xgb_all <- train(log_corrected_potency ~ .,data = traindata1, method = "xgbTree", trControl = train_control, tuneGrid = xgb_model$bestTune, verbosity = 0)
  xgb_imp <- train(log_corrected_potency ~ .,data = traindata3, method = "xgbTree", trControl = train_control, tuneGrid = xgb_model$bestTune, verbosity = 0)
  
  SVR_All_rmse = mean(SVR_All$resample$RMSE)
  SVR_imp_rmse = mean(SVR_imp$resample$RMSE)
  xgb_All_rmse = mean(xgb_all$resample$RMSE)
  xgb_imp_rmse = mean(xgb_imp$resample$RMSE)
  
    ############# identify selected model to fit to full data #############
  # all best models
  all_RMSE = c(SVR_All_rmse, SVR_imp_rmse, xgb_All_rmse, xgb_imp_rmse)
  
  bestmodels = (1:4)[all_RMSE == min(all_RMSE)]
  bestmodel = ifelse(length(bestmodels)==1,bestmodels,sample(bestmodels,1))
  print(all_RMSE)
  print(paste("Best model at outer loop",j,"is",bestmodel))
  
  
  if (bestmodel == 1)   predictvalid = as.numeric(predict(SVR_All, validdata))
  if (bestmodel == 2)   predictvalid = as.numeric(predict(SVR_imp, validdata))
  if (bestmodel == 3)   predictvalid = as.numeric(predict(xgb_all, validdata))
  if (bestmodel == 4)   predictvalid = as.numeric(predict(xgb_imp, validdata))

  
  allpredictedCV[groupj] = predictvalid

}

```
```{r}
result_table <- data.frame(
  Family = data$Family,
  Log_Actual = data$log_corrected_potency,
  Log_Predicted = allpredictedCV
)

result_table <- result_table %>%
  mutate(
    Actual = exp(Log_Actual),
    Predicted = exp(Log_Predicted)
)


ggplot(result_table, aes(x = Actual, y = Predicted, color = Family)) +
  geom_point(alpha = 0.6) +  # Scatter points with color by "Family"
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +  # Line of identity
  geom_smooth(method = "lm", se = FALSE, aes(group = Family), linetype = "solid") +  # Linear fit lines by "Family"
  lims(x = c(35, 240), y = c(35, 240)) +
  labs(
    title = "Actual vs Predicted",
    x = "Actual Values (Unlogged)",
    y = "Predicted Values (Unlogged)",
    color = "Family"
  ) +
  theme_minimal()

MAE <- mean(abs(result_table$Actual - result_table$Predicted))
RMSE <- sqrt(mean((result_table$Actual - result_table$Predicted)^2))
R2 <- 1 - (sum((result_table$Actual - result_table$Predicted)^2) /
           sum((result_table$Actual - mean(result_table$Actual))^2))


cat("Mean Absolute Error (MAE):", MAE, "\n")
cat("Root Mean Squared Error (RMSE):", RMSE, "\n")
cat("R-Squared (RÂ²):", R2, "\n")

```

```{r}

# Calculate log-normal density values for each family
result_table_with_density <- result_table %>%
  group_by(Family) %>%
  mutate(
    n_obs = n(),  # Total observations in the family
    mean_log_actual = mean(log(Actual), na.rm = TRUE),
    sd_log_actual = sd(log(Actual), na.rm = TRUE),
    mean_log_predicted = mean(log(Predicted), na.rm = TRUE),
    sd_log_predicted = sd(log(Predicted), na.rm = TRUE),
    density_actual = dlnorm(Actual, meanlog = mean_log_actual, sdlog = sd_log_actual) * n_obs,
    density_predicted = dlnorm(Predicted, meanlog = mean_log_predicted, sdlog = sd_log_predicted) * n_obs
  )

# Plot the histograms with family-specific log-normal distribution lines
ggplot(result_table_with_density) +
  geom_histogram(aes(x = Actual, fill = "Actual"), bins = 30, alpha = 0.5, position = "identity") +
  geom_histogram(aes(x = Predicted, fill = "Predicted"), bins = 30, alpha = 0.5, position = "identity") +
  geom_line(aes(x = Actual, y = density_actual, color = "Actual"), linetype = "dashed") +
  geom_line(aes(x = Predicted, y = density_predicted, color = "Predicted"), linetype = "dashed") +
  facet_wrap(~Family, scales = "free_y") +  # Split histograms by Family
  scale_fill_manual(values = c("Actual" = "blue", "Predicted" = "orange")) +  # Custom colors for fill
  scale_color_manual(values = c("Actual" = "blue", "Predicted" = "orange")) +  # Custom colors for lines
  labs(
    title = "Histograms of Actual vs Predicted with Family-Specific Log-Normal Distribution",
    x = "Values (Unlogged)",
    y = "Frequency",
    fill = "Variable",
    color = "Log-Normal Curve"
  ) +
  theme_minimal()


```

